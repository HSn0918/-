#gc
## 三色标记法原理

三色标记法将对象分为三类，并用不同的颜色相称：

- 白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。
    
- 灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。
    
- 黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。
![[对象以及波面之间的关系.png]]

标记过程如下：

（1）起初所有的对象都是白色的；

（2）从根对象出发扫描所有可达对象，标记为灰色，放入待处理队列；

（3）从待处理队列中取出灰色对象，将其引用的对象标记为灰色并放入待处理队列中，自身标记为黑色；

（4）重复步骤（3），直到待处理队列为空，此时白色对象即为不可达的“垃圾”，回收白色对象；
![[three_color.gif]]
> 根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：
1. 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
2. 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
3. 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。
## STW
>`STW` 可以是 `Stop the World` 的缩写，也可以是 `Start the World` 的缩写。通常意义上指指代从 `Stop the World` 这一动作发生时到 `Start the World` 这一动作发生时这一段时间间隔，即万物静止。STW 在垃圾回收过程中为了保证实现的正确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图的一段过程。
## 并发标记清除法的难点是什么
在没有用户态代码并发修改`三色抽象`的情况下，回收可以正常结束。但是并发回收的根本问题在于，用户态代码在回收过程中会并发地更新对象图，从而造成赋值器和回收器可能对对象图的结构产生不同的认知。这时以一个固定的三色波面作为回收过程前进的边界则不再合理。
我们不妨考虑赋值器写操作的例子：

| 时序  | 回收器                 | 赋值器                  | 说明                                                                                                    |
| --- | ------------------- | -------------------- | ----------------------------------------------------------------------------------------------------- |
| 1   | shade(A, gray)      |                      | 回收器：根对象的子节点着色为灰色对象                                                                                    |
| 2   | shade(C, black)     |                      | 回收器：当所有子节点着色为灰色后，将节点着为黑色                                                                              |
| 3   |                     | C.ref3 = C.ref2.ref1 | 赋值器：并发的修改了 C 的子节点                                                                                     |
| 4   |                     | A.ref1 = nil         | 赋值器：并发的修改了 A 的子节点                                                                                     |
| 5   | shade(A.ref1, gray) |                      | 回收器：进一步灰色对象的子节点并着色为灰色对象，这时由于 `A.ref1` 为 `nil`，什么事情也没有发生                                               |
| 6   | shade(A, black)     |                      | 回收器：由于所有子节点均已标记，回收器也不会重新扫描已经被标记为黑色的对象，此时 A 被着色为黑色，`scan(A)` 什么也不会发生，进而 B 在此次回收过程中永远不会被标记为黑色，进而错误地被回收。 |
- 初始状态：假设某个黑色对象 C 指向某个灰色对象 A ，而 A 指向白色对象 B；
- `C.ref3 = C.ref2.ref1`：赋值器并发地将黑色对象 C 指向（ref3）了白色对象 B；
- `A.ref1 = nil`：移除灰色对象 A 对白色对象 B 的引用（ref2）；
- 最终状态：在继续扫描的过程中，白色对象 B 永远不会被标记为黑色对象了（回收器不会重新扫描黑色对象），进而对象 B 被错误地回收。
![[gc状态.png]]
总而言之，并发标记清除中面临的一个根本问题就是如何保证标记与清除过程的正确性
## Go 语言中 GC 的流程
当前版本的 Go 以 STW 为界限，可以将 GC 划分为五个阶段：

| 阶段               | 说明                            | 赋值器状态 |
| ---------------- | ----------------------------- | ----- |
| SweepTermination | 清扫终止阶段，为下一个阶段的并发标记做准备工作，启动写屏障 | STW   |
| Mark             | 扫描标记阶段，与赋值器并发执行，写屏障开启         | 并发    |
| MarkTermination  | 标记终止阶段，保证一个周期内标记任务完成，停止写屏障    | STW   |
| GCoff            | 内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭    | 并发    |
| GCoff            | 内存归还阶段，将过多的内存归还给操作系统，写屏障关闭    | 并发    |

具体而言，各个阶段的触发函数分别为：
![[gc过程.png]]
